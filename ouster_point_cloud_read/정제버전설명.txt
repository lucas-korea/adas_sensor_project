build전 체크사항
1. 헤더 정확히 들어가는지 (binary or asii, filds, etc)
2. 프레임 보정하는 수식 정확한지
3. 추출 파일명 형식에 맞는지
4. timestamp.txt 파일 추출되는지 or 안되는지

ver1 : 0819, 이메일로 전달완료
binary와 ascii header가 뒤바뀐 문제가 있음


ver3: 0827, 전달 예정 -> 전달완료
ouster 각도 지정에 있어서 문제 있었던 부분이 있었음 -> 해결
round 함수를 np.round로 대체하여 속도를 1/4로 줄임

ver4: 0830 수정중 파일명 '정제'-> 'pcd추출'로 변경

ver4.1 : find_start() 129.375도에서 0도로 수정
** NIA4차 기간을 거치면서 많이 오염됨

ver5: 20220715 ouster firmware upgrade로 인해 ref_byte 부분 수정
np.round 수정
좌표축 진행방향을 +x로 수정
rm_zero() 불용
저해상도 라이다 추출 코드 삽입 (.bin 파일 마지막 스펠링 L or R 로 구분)
라이다별 내부 파라미터 분리 적용 ( .bin 파일 마지막 스펠링 L or R 로 구분)
취득 데이터 변화로 인해, packet 읽는 크기 수정 (main()  함수)
지그 음영지역 데이터 삭제 코드 추가 parsing_packet()

ver5.1
pcd 이어붙히는 부분 차량 후방(=degree 0)으로 수정. 지그 음영에 접합부 숨기기 위해.
crop_zig_shade() 함수 삽입

ver5.2
고해상도 라이다 맨 윗 채널 삭제 - cal_lidar_pos(), (super resolution 관점에서)

ver5.3
라이다 포지션 반시계 방향으로 2도 틀어짐 수정

ver6.0
64 패킷을 모아서 pcd 파일 생성을 하는 것이 아닌, 각도 체크를 하여 패킷 생략을 무시하고 각도 상 한바퀴 돌면 pcd를 만든다.

ver6a
ver6.0에서, 맨윗 채널 삭제 코드 제외(ver5.2 내용)

ver6b
NIA3차 데이터를 연구용으로 쓰기 위한 코드. ver4.1에서 수정
rm_zero_point() 불용
zig_shade() 삭제
f.read(50) -> f.read(48)
low resolution lidar 고려한 코드 삭제
2도 조정한거 삭제(super resolution이랑 관계 없음)
20230818 작성 : 2023 NIA 생활도로에 사용할 예정
main 함수의 header = f.read(50)  도 48에서 50으로 바꿈

ver6c
NIA4차 데이터 연구용 추출을 위해 생성
ver6a에서 발생. 불필요한 코드 제거 예정
cal_lidar_pos_32ch(), make_ascii_PCDfile(), re_zero() 삭제
2도 조정한거 삭제(super resolution이랑 관계 없음)
parsing_packet()에서 채널 변형, 연구 ppt 참조
연구를 위해 npy 데이터로 만들자. 다만 확장자는 pcd로
make_bin_PCDfile(), cal_lidar_pos() 삭제, make_npyfile() 생성, zig 음영부분 제거하는 코드 삽입, 총 100개 columns 삭제

ver7.0
ver6.0에서 파생
20230819 작성 : NIA 생활도로에 사용할 예정

rm_zero_point() 불용
zig_shade() , make_ascii_PCDfile(), cal_lidar_pos_32ch() 삭제
low resolution lidar 고려한 코드 삭제
2도 조정한거 삭제(super resolution이랑 관계 없음)
- 지금 라이다 패킷이 다 안들어 온다.  모든 라이다 패킷 interval이 2ms로 되어 있다. 원래라면 1.5625ms 이기 때문에 1~2 를 왔다갔다 해야만 한다.
버퍼 문제일수도 있고, for문 돌아가는 속도 문제일수도 있고, 패킷이 너무 커서 문제일수도 있다. 지금 아마 가로해상도가 1024일텐데 반으로 줄여볼까.
우선 180도 지점 tick을 못찾으면 파일명이 이상해지니까 이전 tick이랑 현재 tick이랑 같으면 100을 더해서 하는걸로 임시방편을 하자
-아래 코드 추가
                    if old_tick_ct == tick_ct: # 이전 tick이랑 현재 tick이랑 같으면 100을 더해서 하는걸로 임시방편
                        tick_ct = str(int(tick_ct) + 100)
ver7.1
맨윗 채널 삭제 코드 제외(ver5.2 내용)
find_start() 함수에서, 0도를 찾는게 아닌, 354.375도를 찾는다. 그러면 다음 read에서 0도 부터 읽게 되는것.
                    if old_tick_ct == tick_ct: # 이전 tick이랑 현재 tick이랑 같으면 100을 더해서 하는걸로 임시방편
                        tick_ct = str(int(tick_ct) + 100)
ver7.1.1
